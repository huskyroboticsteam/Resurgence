<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Resurgence (PY2022): util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Resurgence (PY2022)
   </div>
   <div id="projectbrief">Codebase for the Husky Robotics 2021-2022 rover Resurgence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A collection of utility functions and classes with common use-cases.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1AsyncTask.html">AsyncTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class that can be overridden to run long-running tasks and encapsulate task-related data.  <a href="classutil_1_1AsyncTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1latch.html">latch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a countdown latch for threading synchronization.  <a href="classutil_1_1latch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1PeriodicScheduler.html">PeriodicScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a single thread to periodically invoke callbacks at a given frequency.  <a href="classutil_1_1PeriodicScheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1PeriodicTask.html">PeriodicTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a task that executes a function periodically.  <a href="classutil_1_1PeriodicTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1RAIIHelper.html">RAIIHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for executing a function when leaving a scope, in RAII-style.  <a href="classutil_1_1RAIIHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ScopedTimer.html">ScopedTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class that helps with timing.  <a href="classutil_1_1ScopedTimer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1Watchdog.html">Watchdog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a thread-safe watchdog.  <a href="classutil_1_1Watchdog.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac5b19fd01dc75ef0fd8277b3868b1522" id="r_ac5b19fd01dc75ef0fd8277b3868b1522"><td class="memItemLeft" align="right" valign="top"><a id="ac5b19fd01dc75ef0fd8277b3868b1522" name="ac5b19fd01dc75ef0fd8277b3868b1522"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>json</b> = <a class="elRef" href="https://nlohmann.github.io/json/doxygen/namespacenlohmann_a2bfd99e845a2e5cd90aeaf1b1431f474.html#a2bfd99e845a2e5cd90aeaf1b1431f474">nlohmann::json</a></td></tr>
<tr class="separator:ac5b19fd01dc75ef0fd8277b3868b1522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ec65fbb4741a5519e8b8d096726ce3" id="r_a15ec65fbb4741a5519e8b8d096726ce3"><td class="memItemLeft" align="right" valign="top"><a id="a15ec65fbb4741a5519e8b8d096726ce3" name="a15ec65fbb4741a5519e8b8d096726ce3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>val_t</b> = <a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json_ac68cb65a7f3517f0c5b1d3a4967406ad.html#ac68cb65a7f3517f0c5b1d3a4967406ad">json::value_t</a></td></tr>
<tr class="separator:a15ec65fbb4741a5519e8b8d096726ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72ec8c050fac369cc25260df2234ca5" id="r_ab72ec8c050fac369cc25260df2234ca5"><td class="memItemLeft" align="right" valign="top"><a id="ab72ec8c050fac369cc25260df2234ca5" name="ab72ec8c050fac369cc25260df2234ca5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>dseconds</b> = <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01839.html">std::chrono::duration</a>&lt;double, std::chrono::seconds::period&gt;</td></tr>
<tr class="separator:ab72ec8c050fac369cc25260df2234ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afe7353db429b36774cf7c2b477eaa493" id="r_afe7353db429b36774cf7c2b477eaa493"><td class="memItemLeft" align="right" valign="top"><a id="afe7353db429b36774cf7c2b477eaa493" name="afe7353db429b36774cf7c2b477eaa493"></a>
<a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (control::DriveMode mode)</td></tr>
<tr class="separator:afe7353db429b36774cf7c2b477eaa493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59535c29b1922ba23f28bdd79857da8e" id="r_a59535c29b1922ba23f28bdd79857da8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59535c29b1922ba23f28bdd79857da8e">almostEqual</a> (double a, double b, double <a class="elRef" href="https://docs.opencv.org/4.2.0/d0/d86/group__gapi__matrixop.html#gad538f94c264624d0ea78b853d53adcb2">threshold</a>=1e-6)</td></tr>
<tr class="memdesc:a59535c29b1922ba23f28bdd79857da8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two numbers are approximately equal.  <br /></td></tr>
<tr class="separator:a59535c29b1922ba23f28bdd79857da8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b20b0142e53d95a9c4831635f657cb1" id="r_a6b20b0142e53d95a9c4831635f657cb1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6b20b0142e53d95a9c4831635f657cb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b20b0142e53d95a9c4831635f657cb1">to_string&lt; bool &gt;</a> (const bool &amp;val)</td></tr>
<tr class="memdesc:a6b20b0142e53d95a9c4831635f657cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a boolean to a string.  <br /></td></tr>
<tr class="separator:a6b20b0142e53d95a9c4831635f657cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44747fa29acced278a3a6cc7335a5698" id="r_a44747fa29acced278a3a6cc7335a5698"><td class="memItemLeft" align="right" valign="top"><a id="a44747fa29acced278a3a6cc7335a5698" name="a44747fa29acced278a3a6cc7335a5698"></a>
frozen::string&#160;</td><td class="memItemRight" valign="bottom"><b>freezeStr</b> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;str)</td></tr>
<tr class="memdesc:a44747fa29acced278a3a6cc7335a5698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> to a frozen::string. <br /></td></tr>
<tr class="separator:a44747fa29acced278a3a6cc7335a5698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920531d6160b5a6c11d7c3e6ca5d783f" id="r_a920531d6160b5a6c11d7c3e6ca5d783f"><td class="memTemplParams" colspan="2">template&lt;typename K, typename V&gt; </td></tr>
<tr class="memitem:a920531d6160b5a6c11d7c3e6ca5d783f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a08055.html">std::unordered_set</a>&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a920531d6160b5a6c11d7c3e6ca5d783f">keySet</a> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a08047.html">std::unordered_map</a>&lt; K, V &gt; &amp;input)</td></tr>
<tr class="memdesc:a920531d6160b5a6c11d7c3e6ca5d783f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the keys of the given map.  <br /></td></tr>
<tr class="separator:a920531d6160b5a6c11d7c3e6ca5d783f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a49bcfa8ed1a20f65a28d004e7af74" id="r_a38a49bcfa8ed1a20f65a28d004e7af74"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a38a49bcfa8ed1a20f65a28d004e7af74"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38a49bcfa8ed1a20f65a28d004e7af74">to_string</a> (const T &amp;val)</td></tr>
<tr class="memdesc:a38a49bcfa8ed1a20f65a28d004e7af74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given value to a string.  <br /></td></tr>
<tr class="separator:a38a49bcfa8ed1a20f65a28d004e7af74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b20b0142e53d95a9c4831635f657cb1" id="r_a6b20b0142e53d95a9c4831635f657cb1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6b20b0142e53d95a9c4831635f657cb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b20b0142e53d95a9c4831635f657cb1">to_string&lt; bool &gt;</a> (const bool &amp;val)</td></tr>
<tr class="memdesc:a6b20b0142e53d95a9c4831635f657cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a boolean to a string.  <br /></td></tr>
<tr class="separator:a6b20b0142e53d95a9c4831635f657cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965e5c3ac37ea1fff5df67e8a4f2fe62" id="r_a965e5c3ac37ea1fff5df67e8a4f2fe62"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U&gt; </td></tr>
<tr class="memitem:a965e5c3ac37ea1fff5df67e8a4f2fe62"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a02895.html">std::tuple</a>&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a965e5c3ac37ea1fff5df67e8a4f2fe62">pairToTuple</a> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07803.html">std::pair</a>&lt; T, U &gt; &amp;pair)</td></tr>
<tr class="memdesc:a965e5c3ac37ea1fff5df67e8a4f2fe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pair to a tuple.  <br /></td></tr>
<tr class="separator:a965e5c3ac37ea1fff5df67e8a4f2fe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab570e599e6aa85b419b583ae53b607f1" id="r_ab570e599e6aa85b419b583ae53b607f1"><td class="memItemLeft" align="right" valign="top"><a id="ab570e599e6aa85b419b583ae53b607f1" name="ab570e599e6aa85b419b583ae53b607f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasKey</b> (const <a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a> &amp;j, const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;key)</td></tr>
<tr class="memdesc:ab570e599e6aa85b419b583ae53b607f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given json object has the given key. <br /></td></tr>
<tr class="separator:ab570e599e6aa85b419b583ae53b607f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabe627a0fcfdd21b5170e4108c90c0b" id="r_acabe627a0fcfdd21b5170e4108c90c0b"><td class="memItemLeft" align="right" valign="top"><a id="acabe627a0fcfdd21b5170e4108c90c0b" name="acabe627a0fcfdd21b5170e4108c90c0b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>validateKey</b> (const <a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a> &amp;j, const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;key, const val_t &amp;type)</td></tr>
<tr class="memdesc:acabe627a0fcfdd21b5170e4108c90c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given json object has the given key with the given type. <br /></td></tr>
<tr class="separator:acabe627a0fcfdd21b5170e4108c90c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c736fa7ad5a68e89f3f56be0235aff" id="r_a02c736fa7ad5a68e89f3f56be0235aff"><td class="memItemLeft" align="right" valign="top"><a id="a02c736fa7ad5a68e89f3f56be0235aff" name="a02c736fa7ad5a68e89f3f56be0235aff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>validateKey</b> (const <a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a> &amp;j, const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;key, const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a08055.html">std::unordered_set</a>&lt; val_t &gt; &amp;types)</td></tr>
<tr class="memdesc:a02c736fa7ad5a68e89f3f56be0235aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given json object has the given key, with a type in the given set of types. <br /></td></tr>
<tr class="separator:a02c736fa7ad5a68e89f3f56be0235aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222e14af5a8aee85361adc9670ce33b6" id="r_a222e14af5a8aee85361adc9670ce33b6"><td class="memItemLeft" align="right" valign="top"><a id="a222e14af5a8aee85361adc9670ce33b6" name="a222e14af5a8aee85361adc9670ce33b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>validateOneOf</b> (const <a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a> &amp;j, const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;key, const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a08055.html">std::unordered_set</a>&lt; <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &gt; &amp;vals)</td></tr>
<tr class="memdesc:a222e14af5a8aee85361adc9670ce33b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the value in the given json object at the given key is a string in the given set of allowed values. <br /></td></tr>
<tr class="separator:a222e14af5a8aee85361adc9670ce33b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54731506a7b3ae7300a6937b59809d4" id="r_aa54731506a7b3ae7300a6937b59809d4"><td class="memItemLeft" align="right" valign="top"><a id="aa54731506a7b3ae7300a6937b59809d4" name="aa54731506a7b3ae7300a6937b59809d4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>validateRange</b> (const <a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a> &amp;j, const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;key, double <a class="elRef" href="https://docs.opencv.org/4.2.0/d2/de8/group__core__array.html#ga9af368f182ee76d0463d0d8d5330b764">min</a>, double <a class="elRef" href="https://docs.opencv.org/4.2.0/d2/de8/group__core__array.html#gacc40fa15eac0fb83f8ca70b7cc0b588d">max</a>)</td></tr>
<tr class="memdesc:aa54731506a7b3ae7300a6937b59809d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the value in the given json object at the given key is a floating-point number between min and max, inclusive. <br /></td></tr>
<tr class="separator:aa54731506a7b3ae7300a6937b59809d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9d28b43adad26f05fd6a983e53b032" id="r_a7e9d28b43adad26f05fd6a983e53b032"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e9d28b43adad26f05fd6a983e53b032">numericalJacobian</a> (const std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; &amp;func, const Eigen::VectorXd &amp;x, int outputDim)</td></tr>
<tr class="memdesc:a7e9d28b43adad26f05fd6a983e53b032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the jacobian of a multivariate function using finite differences.  <br /></td></tr>
<tr class="separator:a7e9d28b43adad26f05fd6a983e53b032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef644ff86939b8fb6d59d0fce202e8fd" id="r_aef644ff86939b8fb6d59d0fce202e8fd"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef644ff86939b8fb6d59d0fce202e8fd">getNormalSeed</a> ()</td></tr>
<tr class="memdesc:aef644ff86939b8fb6d59d0fce202e8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the random seed used for <a class="el" href="#a1b6af13be4df99a79372afcde0448fe4" title="Sample from the standard normal distribution.">util::stdn()</a>.  <br /></td></tr>
<tr class="separator:aef644ff86939b8fb6d59d0fce202e8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6af13be4df99a79372afcde0448fe4" id="r_a1b6af13be4df99a79372afcde0448fe4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b6af13be4df99a79372afcde0448fe4">stdn</a> (int thread_id)</td></tr>
<tr class="memdesc:a1b6af13be4df99a79372afcde0448fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample from the standard normal distribution.  <br /></td></tr>
<tr class="separator:a1b6af13be4df99a79372afcde0448fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b711935ef15b31f63117e127832e87d" id="r_a6b711935ef15b31f63117e127832e87d"><td class="memItemLeft" align="right" valign="top"><a id="a6b711935ef15b31f63117e127832e87d" name="a6b711935ef15b31f63117e127832e87d"></a>
<a class="elRef" href="https://docs.opencv.org/4.2.0/d2/d75/namespacecv.html#a95a13348625f7bf50cc851d1fddea33b">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getUnixTime</b> ()</td></tr>
<tr class="separator:a6b711935ef15b31f63117e127832e87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d368bf202be12ecd7f66176f3088da3" id="r_a4d368bf202be12ecd7f66176f3088da3"><td class="memTemplParams" colspan="2">template&lt;typename Rep, typename Period&gt; </td></tr>
<tr class="memitem:a4d368bf202be12ecd7f66176f3088da3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d368bf202be12ecd7f66176f3088da3">durationToSec</a> (<a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01839.html">std::chrono::duration</a>&lt; Rep, Period &gt; dur)</td></tr>
<tr class="memdesc:a4d368bf202be12ecd7f66176f3088da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a duration to seconds, as a double.  <br /></td></tr>
<tr class="separator:a4d368bf202be12ecd7f66176f3088da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddfab6615abd54e40db44dff188c139" id="r_a2ddfab6615abd54e40db44dff188c139"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ddfab6615abd54e40db44dff188c139">quatToHeading</a> (double qw, double qx, double qy, double qz)</td></tr>
<tr class="memdesc:a2ddfab6615abd54e40db44dff188c139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the heading from a quaternion.  <br /></td></tr>
<tr class="separator:a2ddfab6615abd54e40db44dff188c139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3359ae5dac1ea4f9186c133f3e7186d" id="r_ac3359ae5dac1ea4f9186c133f3e7186d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3359ae5dac1ea4f9186c133f3e7186d">quatToHeading</a> (const <a class="elRef" href="https://eigen.tuxfamily.org/dox/group__Geometry__Module.html#ga5daab8e66aa480465000308455578830">Eigen::Quaterniond</a> &amp;quat)</td></tr>
<tr class="memdesc:ac3359ae5dac1ea4f9186c133f3e7186d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the heading from a quaternion.  <br /></td></tr>
<tr class="separator:ac3359ae5dac1ea4f9186c133f3e7186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe82846305c20a7bcdcb348b11b68ad4" id="r_afe82846305c20a7bcdcb348b11b68ad4"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__Geometry__Module.html#ga5daab8e66aa480465000308455578830">Eigen::Quaterniond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe82846305c20a7bcdcb348b11b68ad4">eulerAnglesToQuat</a> (const <a class="el" href="structnavtypes_1_1eulerangles__t.html">navtypes::eulerangles_t</a> &amp;rpy)</td></tr>
<tr class="memdesc:afe82846305c20a7bcdcb348b11b68ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert euler angles to a quaternion representation.  <br /></td></tr>
<tr class="separator:afe82846305c20a7bcdcb348b11b68ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9ae4acf4ddb63d9633bb398b0616ee" id="r_aae9ae4acf4ddb63d9633bb398b0616ee"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">points_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae9ae4acf4ddb63d9633bb398b0616ee">transformReadings</a> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">navtypes::points_t</a> &amp;ps, const navtypes::transform_t &amp;tf)</td></tr>
<tr class="memdesc:aae9ae4acf4ddb63d9633bb398b0616ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a set of points to a different reference frame.  <br /></td></tr>
<tr class="separator:aae9ae4acf4ddb63d9633bb398b0616ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fdb65ab2da6e0935db38a4a7a403fa" id="r_a56fdb65ab2da6e0935db38a4a7a403fa"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">trajectory_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56fdb65ab2da6e0935db38a4a7a403fa">transformTraj</a> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">navtypes::trajectory_t</a> &amp;traj, const navtypes::transform_t &amp;tf)</td></tr>
<tr class="memdesc:a56fdb65ab2da6e0935db38a4a7a403fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a trajectory to a different reference frame.  <br /></td></tr>
<tr class="separator:a56fdb65ab2da6e0935db38a4a7a403fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e16f63251e3c2a45a1d6a2bde6b21a" id="r_a02e16f63251e3c2a45a1d6a2bde6b21a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e16f63251e3c2a45a1d6a2bde6b21a">collides</a> (const navtypes::transform_t &amp;tf, const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">navtypes::points_t</a> &amp;lms, double radius)</td></tr>
<tr class="memdesc:a02e16f63251e3c2a45a1d6a2bde6b21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for intersection between a pose and a point cloud.  <br /></td></tr>
<tr class="separator:a02e16f63251e3c2a45a1d6a2bde6b21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d75d06aaea966512ccaad4538b79101" id="r_a1d75d06aaea966512ccaad4538b79101"><td class="memItemLeft" align="right" valign="top">transform_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d75d06aaea966512ccaad4538b79101">toTransformRotateFirst</a> (double x, double y, double theta)</td></tr>
<tr class="memdesc:a1d75d06aaea966512ccaad4538b79101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid transform that takes a point from the map-frame to a frame that was rotated CCW by theta and shifted (x,y) along the new axes.  <br /></td></tr>
<tr class="separator:a1d75d06aaea966512ccaad4538b79101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10a4493a1c38a1868ea8af92bac1503" id="r_aa10a4493a1c38a1868ea8af92bac1503"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa10a4493a1c38a1868ea8af92bac1503">closestHeading</a> (double theta, double prev_theta)</td></tr>
<tr class="memdesc:aa10a4493a1c38a1868ea8af92bac1503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an equivalent heading that is within &pi; radians of another heading.  <br /></td></tr>
<tr class="separator:aa10a4493a1c38a1868ea8af92bac1503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcec0cc3869936542227f6e663ad2892" id="r_afcec0cc3869936542227f6e663ad2892"><td class="memItemLeft" align="right" valign="top">pose_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcec0cc3869936542227f6e663ad2892">toPose</a> (const navtypes::transform_t &amp;trf, double prev_theta)</td></tr>
<tr class="memdesc:afcec0cc3869936542227f6e663ad2892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a transform, gives a robot pose that would have that transform.  <br /></td></tr>
<tr class="separator:afcec0cc3869936542227f6e663ad2892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491b92a3b8414fcfa7ea00bdc9cdcd3e" id="r_a491b92a3b8414fcfa7ea00bdc9cdcd3e"><td class="memItemLeft" align="right" valign="top">transform_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a491b92a3b8414fcfa7ea00bdc9cdcd3e">toTransform</a> (const navtypes::pose_t &amp;pose)</td></tr>
<tr class="memdesc:a491b92a3b8414fcfa7ea00bdc9cdcd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pose to a rigid transform.  <br /></td></tr>
<tr class="separator:a491b92a3b8414fcfa7ea00bdc9cdcd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d02ad5947a1c5a8b80513f8c72ecef" id="r_aa2d02ad5947a1c5a8b80513f8c72ecef"><td class="memItemLeft" align="right" valign="top"><a id="aa2d02ad5947a1c5a8b80513f8c72ecef" name="aa2d02ad5947a1c5a8b80513f8c72ecef"></a>
<a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (robot::types::jointid_t joint)</td></tr>
<tr class="separator:aa2d02ad5947a1c5a8b80513f8c72ecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fe0173f619800199de889c8411975f" id="r_a16fe0173f619800199de889c8411975f"><td class="memItemLeft" align="right" valign="top"><a id="a16fe0173f619800199de889c8411975f" name="a16fe0173f619800199de889c8411975f"></a>
<a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="namespacerobot_1_1types.html#add39bf4059de53554504f535bab93bba">robot::types::CameraID</a> &amp;id)</td></tr>
<tr class="separator:a16fe0173f619800199de889c8411975f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7983f873a316e073dd6ecdabb82379da" id="r_a7983f873a316e073dd6ecdabb82379da"><td class="memItemLeft" align="right" valign="top"><a id="a7983f873a316e073dd6ecdabb82379da" name="a7983f873a316e073dd6ecdabb82379da"></a>
<a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="namespacerobot_1_1types.html#aa93c10246999d2fdb71ba7bdb792c235">robot::types::mountedperipheral_t</a> peripheral)</td></tr>
<tr class="separator:a7983f873a316e073dd6ecdabb82379da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23ee4a39a601b2b09e9f35baa9e9532" id="r_af23ee4a39a601b2b09e9f35baa9e9532"><td class="memItemLeft" align="right" valign="top"><a id="af23ee4a39a601b2b09e9f35baa9e9532" name="af23ee4a39a601b2b09e9f35baa9e9532"></a>
<a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (robot::types::servoid_t servo)</td></tr>
<tr class="separator:af23ee4a39a601b2b09e9f35baa9e9532"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af941384c3c1746bf015a31daf66829ec" id="r_af941384c3c1746bf015a31daf66829ec"><td class="memItemLeft" align="right" valign="top"><a id="af941384c3c1746bf015a31daf66829ec" name="af941384c3c1746bf015a31daf66829ec"></a>
constexpr double&#160;</td><td class="memItemRight" valign="bottom"><b>epsilon</b> = 1e-5</td></tr>
<tr class="memdesc:af941384c3c1746bf015a31daf66829ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small positive value, near zero. <br /></td></tr>
<tr class="separator:af941384c3c1746bf015a31daf66829ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of utility functions and classes with common use-cases. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a59535c29b1922ba23f28bdd79857da8e" name="a59535c29b1922ba23f28bdd79857da8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59535c29b1922ba23f28bdd79857da8e">&#9670;&#160;</a></span>almostEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool util::almostEqual </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>threshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-6</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two numbers are approximately equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number. </td></tr>
    <tr><td class="paramname">b</td><td>The second number. </td></tr>
    <tr><td class="paramname">threshold</td><td>If <code>|a-b|&ge;threshold</code> then they are not approximately equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <code>|a-b|&lt;threshold</code>. </dd></dl>

</div>
</div>
<a id="aa10a4493a1c38a1868ea8af92bac1503" name="aa10a4493a1c38a1868ea8af92bac1503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10a4493a1c38a1868ea8af92bac1503">&#9670;&#160;</a></span>closestHeading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double util::closestHeading </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>theta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>prev_theta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an equivalent heading that is within &pi; radians of another heading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The heading to get the equivalent heading for. </td></tr>
    <tr><td class="paramname">prev_theta</td><td>The heading that the returned heading is in the neighborhood of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A heading equivalent to <code class="param">theta</code> that is within &pi; radians of <code class="param">prev_theta</code>. </dd></dl>

</div>
</div>
<a id="a02e16f63251e3c2a45a1d6a2bde6b21a" name="a02e16f63251e3c2a45a1d6a2bde6b21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e16f63251e3c2a45a1d6a2bde6b21a">&#9670;&#160;</a></span>collides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool util::collides </td>
          <td>(</td>
          <td class="paramtype">const navtypes::transform_t &amp;</td>          <td class="paramname"><span class="paramname"><em>tf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">navtypes::points_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for intersection between a pose and a point cloud. </p>
<p>Checks if any point of <code class="param">lms</code> is within <code class="param">radius</code> distance of the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td>The robot transform. </td></tr>
    <tr><td class="paramname">lms</td><td>The points to check against for intersection. </td></tr>
    <tr><td class="paramname">radius</td><td>The minimum distance from the robot to a point to not count as an intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If any point of <code class="param">lms</code> is within <code class="param">radius</code> distance of the robot. </dd></dl>

</div>
</div>
<a id="a4d368bf202be12ecd7f66176f3088da3" name="a4d368bf202be12ecd7f66176f3088da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d368bf202be12ecd7f66176f3088da3">&#9670;&#160;</a></span>durationToSec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep, typename Period&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double util::durationToSec </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01839.html">std::chrono::duration</a>&lt; Rep, Period &gt;</td>          <td class="paramname"><span class="paramname"><em>dur</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a duration to seconds, as a double. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>The rep of the duration. </td></tr>
    <tr><td class="paramname">Period</td><td>The period of the duration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dur</td><td>The duration to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The length of the duration, in seconds. </dd></dl>

</div>
</div>
<a id="afe82846305c20a7bcdcb348b11b68ad4" name="afe82846305c20a7bcdcb348b11b68ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe82846305c20a7bcdcb348b11b68ad4">&#9670;&#160;</a></span>eulerAnglesToQuat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__Geometry__Module.html#ga5daab8e66aa480465000308455578830">Eigen::Quaterniond</a> util::eulerAnglesToQuat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnavtypes_1_1eulerangles__t.html">navtypes::eulerangles_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rpy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert euler angles to a quaternion representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpy</td><td>The euler angles to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="elRef" href="https://eigen.tuxfamily.org/dox/group__Geometry__Module.html#ga5daab8e66aa480465000308455578830">Eigen::Quaterniond</a> The same orientation represented as a quaternion. </dd></dl>

</div>
</div>
<a id="aef644ff86939b8fb6d59d0fce202e8fd" name="aef644ff86939b8fb6d59d0fce202e8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef644ff86939b8fb6d59d0fce202e8fd">&#9670;&#160;</a></span>getNormalSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long util::getNormalSeed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the random seed used for <a class="el" href="#a1b6af13be4df99a79372afcde0448fe4" title="Sample from the standard normal distribution.">util::stdn()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The random seed. </dd></dl>

</div>
</div>
<a id="a920531d6160b5a6c11d7c3e6ca5d783f" name="a920531d6160b5a6c11d7c3e6ca5d783f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920531d6160b5a6c11d7c3e6ca5d783f">&#9670;&#160;</a></span>keySet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a08055.html">std::unordered_set</a>&lt; K &gt; util::keySet </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a08047.html">std::unordered_map</a>&lt; K, V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keys of the given map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">An</td><td>unordered map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The keys of the given map, as an unordered set. </dd></dl>

</div>
</div>
<a id="a7e9d28b43adad26f05fd6a983e53b032" name="a7e9d28b43adad26f05fd6a983e53b032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9d28b43adad26f05fd6a983e53b032">&#9670;&#160;</a></span>numericalJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd util::numericalJacobian </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>outputDim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the jacobian of a multivariate function using finite differences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to estimate the jacobian of. </td></tr>
    <tr><td class="paramname">x</td><td>The point around which to calculate the jacobian. </td></tr>
    <tr><td class="paramname">outputDim</td><td>The dimension of the output space of <code class="param">func</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::MatrixXd An n-by-m matrix where n is the output dimension and m is the input dimension of <code class="param">func</code>. </dd></dl>

</div>
</div>
<a id="a965e5c3ac37ea1fff5df67e8a4f2fe62" name="a965e5c3ac37ea1fff5df67e8a4f2fe62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965e5c3ac37ea1fff5df67e8a4f2fe62">&#9670;&#160;</a></span>pairToTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a02895.html">std::tuple</a>&lt; T, U &gt; util::pairToTuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07803.html">std::pair</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pair</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a pair to a tuple. </p>
<p>Elements are copied to the returned tuple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the first element. </td></tr>
    <tr><td class="paramname">U</td><td>The type of the second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>The pair to convert to a tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a02895.html">std::tuple&lt;T, U&gt;</a> The converted tuple. </dd></dl>

</div>
</div>
<a id="ac3359ae5dac1ea4f9186c133f3e7186d" name="ac3359ae5dac1ea4f9186c133f3e7186d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3359ae5dac1ea4f9186c133f3e7186d">&#9670;&#160;</a></span>quatToHeading() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double util::quatToHeading </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://eigen.tuxfamily.org/dox/group__Geometry__Module.html#ga5daab8e66aa480465000308455578830">Eigen::Quaterniond</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>quat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the heading from a quaternion. </p>
<p>Given a quaternion defined by out coordinate system, extract the CCW heading, in radians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>The quaternion to extract the heading from. This does not need to be normalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The CCW heading, in radians. </dd></dl>

</div>
</div>
<a id="a2ddfab6615abd54e40db44dff188c139" name="a2ddfab6615abd54e40db44dff188c139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddfab6615abd54e40db44dff188c139">&#9670;&#160;</a></span>quatToHeading() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double util::quatToHeading </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>qw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>qx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>qy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>qz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the heading from a quaternion. </p>
<p>Given a quaternion defined by out coordinate system, extract the CCW heading, in radians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qw</td><td>The w component of the quaternion. </td></tr>
    <tr><td class="paramname">qx</td><td>The x component of the quaternion. </td></tr>
    <tr><td class="paramname">qy</td><td>The y component of the quaternion. </td></tr>
    <tr><td class="paramname">qz</td><td>The z component of the quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The CCW heading, in radians. </dd></dl>

</div>
</div>
<a id="a1b6af13be4df99a79372afcde0448fe4" name="a1b6af13be4df99a79372afcde0448fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6af13be4df99a79372afcde0448fe4">&#9670;&#160;</a></span>stdn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double util::stdn </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thread_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample from the standard normal distribution. </p>
<p>The thread_id is used to choose which random number generator to use. This is important when trying to rerun a particular random seed; each thread needs its own dedicated sequence of random numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Either 0 or 1, denoting which random number generator use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>

</div>
</div>
<a id="a38a49bcfa8ed1a20f65a28d004e7af74" name="a38a49bcfa8ed1a20f65a28d004e7af74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a49bcfa8ed1a20f65a28d004e7af74">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> util::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given value to a string. </p>
<p>This method is necessary because we cannot extend the std namespace; having our own method allows us to extend it with template specializations whenever we want, and have it "fall
back" to using the std version when no specialization is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type of the value to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of that value, as a <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>. The exact representation of the value is up to the implementation. </dd></dl>

</div>
</div>
<a id="a6b20b0142e53d95a9c4831635f657cb1" name="a6b20b0142e53d95a9c4831635f657cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b20b0142e53d95a9c4831635f657cb1">&#9670;&#160;</a></span>to_string&lt; bool &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> util::to_string&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a boolean to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to get the string representation of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"true" iff val, otherwise "false". </dd></dl>

</div>
</div>
<a id="a6b20b0142e53d95a9c4831635f657cb1" name="a6b20b0142e53d95a9c4831635f657cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b20b0142e53d95a9c4831635f657cb1">&#9670;&#160;</a></span>to_string&lt; bool &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> util::to_string&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a boolean to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to get the string representation of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"true" iff val, otherwise "false". </dd></dl>

</div>
</div>
<a id="afcec0cc3869936542227f6e663ad2892" name="afcec0cc3869936542227f6e663ad2892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcec0cc3869936542227f6e663ad2892">&#9670;&#160;</a></span>toPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">navtypes::pose_t util::toPose </td>
          <td>(</td>
          <td class="paramtype">const navtypes::transform_t &amp;</td>          <td class="paramname"><span class="paramname"><em>trf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>prev_theta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a transform, gives a robot pose that would have that transform. </p>
<p>That is, the x,y location and angle theta of the robot such that left-multiplying a map-frame coordinate by <code>trf</code> will give you the robot-frame coordinate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trf</td><td>The rigid transform representing a robot position. This transform would take points from the map frame to the robot frame. </td></tr>
    <tr><td class="paramname">prev_theta</td><td>Since heading is modular, the returned heading value will be chosen to be within 2&pi; radians of this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The robot pose.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>THIS IS AN INVERSE OF <a class="el" href="#a491b92a3b8414fcfa7ea00bdc9cdcd3e" title="Convert a pose to a rigid transform.">util::toTransform</a>, NOT <a class="el" href="#a1d75d06aaea966512ccaad4538b79101" title="Creates a rigid transform that takes a point from the map-frame to a frame that was rotated CCW by th...">util::toTransformRotateFirst</a>. The parameters of the latter are not a robot pose (rotation and translation operations do not commute). </dd></dl>

</div>
</div>
<a id="a491b92a3b8414fcfa7ea00bdc9cdcd3e" name="a491b92a3b8414fcfa7ea00bdc9cdcd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491b92a3b8414fcfa7ea00bdc9cdcd3e">&#9670;&#160;</a></span>toTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">navtypes::transform_t util::toTransform </td>
          <td>(</td>
          <td class="paramtype">const navtypes::pose_t &amp;</td>          <td class="paramname"><span class="paramname"><em>pose</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a pose to a rigid transform. </p>
<p>Calculate the rigid transform associated with the given pose. This rigid transform takes points from the global frame to the robot frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pose</td><td>The current robot pose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>navtypes::transform_t The rigid transform denoting the pose of the robot. </dd></dl>

</div>
</div>
<a id="a1d75d06aaea966512ccaad4538b79101" name="a1d75d06aaea966512ccaad4538b79101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d75d06aaea966512ccaad4538b79101">&#9670;&#160;</a></span>toTransformRotateFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">navtypes::transform_t util::toTransformRotateFirst </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>theta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rigid transform that takes a point from the map-frame to a frame that was rotated CCW by theta and shifted (x,y) along the new axes. </p>
<p>This can also be viewed as rotating a map-frame point CW by theta and then shifting by (-x,-y) along the map axes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate in map-space of the origin of the new frame. </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate in map-space of the origin of the new frame. </td></tr>
    <tr><td class="paramname">theta</td><td>The CCW angle between the new frame and the old frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A rigid transform that changes frames as described. </dd></dl>

</div>
</div>
<a id="aae9ae4acf4ddb63d9633bb398b0616ee" name="aae9ae4acf4ddb63d9633bb398b0616ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9ae4acf4ddb63d9633bb398b0616ee">&#9670;&#160;</a></span>transformReadings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">navtypes::points_t</a> util::transformReadings </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">navtypes::points_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const navtypes::transform_t &amp;</td>          <td class="paramname"><span class="paramname"><em>tf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a set of points to a different reference frame. </p>
<p>Applies <code class="param">tf^-1</code> to every element of <code class="param">ps</code> and returns the transformed points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>The points to convert between reference frames. </td></tr>
    <tr><td class="paramname">tf</td><td>The transform whose inverse will be applied to the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Points such that the the i-th point is equivalent to <code>tf^-1*ps</code>[i].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The inverse of the given transform is applied to every point, not the transform itself. </dd></dl>

</div>
</div>
<a id="a56fdb65ab2da6e0935db38a4a7a403fa" name="a56fdb65ab2da6e0935db38a4a7a403fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fdb65ab2da6e0935db38a4a7a403fa">&#9670;&#160;</a></span>transformTraj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">navtypes::trajectory_t</a> util::transformTraj </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a07967.html">navtypes::trajectory_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>traj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const navtypes::transform_t &amp;</td>          <td class="paramname"><span class="paramname"><em>tf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a trajectory to a different reference frame. </p>
<p>Applies <code class="param">tf</code> on the right for every element of <code class="param">traj</code> and returns the transformed trajectory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traj</td><td>The trajectory to transform. </td></tr>
    <tr><td class="paramname">tf</td><td>The transform to apply on the right to every element of <code class="param">traj</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed trajectory, such that the i-th element is <code>traj</code>[i]*tf. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
